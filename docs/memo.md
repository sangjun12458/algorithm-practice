# 알고리즘 문제별 개선 메모

---

### 1406. 에디터 (문자열) 
#### 개선
- 문자열을 직접 조작할 경우 O(N) 시간이 소요된다.
- 단순 문자열 문제이지만 리스트로 처리하여 삽입/삭제 연산 속도 향상.
- 커서를 기준으로 두 개의 스택(left, right)을 활용한 방식이 효율적.

---

### 16953. A → B (BFS, greedy)
#### 개선 1: BFS + 조건 필터링
- 큐에 넣기 전 조건을 미리 체크하여 불필요한 탐색 줄임.
- 상태를 '(숫자, 연산횟수)' 형태의 튜플로 저장해 메모리 절약.
- 약 1900KB 메모리, 28ms 시간 절약
#### 개선 2: 역방향 + 그리디
- B에서 A로 거꾸로 이동하면서, 가능한 경우만 역추적
- 정수가 되지 않는 연산 제외 가능하므로 경우의 수가 급감
- 약 4400KB 메모리, 76ms 시간 절약

---

### 2108. 통계학(구현)
#### 개선
- 'collections.Counter'를 활용하여 간결하게 빈도 계산 가능.
- 'most_common' 함수는 빈도 순으로 정렬 및 동일 빈도 시 본래 순서 유지.
- 내장 함수 활용으로 코드 간결화 및 오류 방지

---

### 1967. 트리의 지름 (DFS, BFS)
- python으로 재귀 문제를 푸는 경우 (예: dfs), 제한에 걸리는 경우가 있다. 따라서 'sys.setrecursionlimit(10**6)'과 같이 설정한다.
#### 개선
- 노드 수에 맞는 n + 1 크기의 리스트 생성으로 메모리 절약
- graph[a].append((b, w)), graph[b].append((a, w)) 형태로 간선 양방향 연결
- 방문 여부를 리스트로 체크하여 중복을 제거하고 무한 루프를 방지
- DFS 대신 BFS를 2회 수행하여 임의 노드 → 가장 먼 노드 → 다시 가장 먼 노드로 이어지는 경로를 찾는 방식이 정확하고 효율적 (약 500KB 메모리, 220ms 시간 절약)

---

### 12865. 평범한 배낭 (DP)
#### 문제점
- 첫 아이템의 무게가 k보다 큰 경우 IndexError
#### 개선
- 1차원 DP로 최적화
- 227544 -> 36264 (KB), 4680 -> 2480 (ms)

---

### 11054. 가장 긴 바이토닉 부분 수열 (LIS, DP)
- 각 숫자가 끝이 되는 LIS를 계산
- 기준점으로 앞에서 LIS, 뒤에서 역으로 LIS를 계산

---

### 1920. 수 찾기
#### 개선
- 정수로 명시되어 있으므로 정수로 처리
- dict보다 set이 더 직관적이며 더 좋을 수 있다.
- print를 한 번만 출력하여 최적화

---

### 2805. 나무 자르기
- 리스트가 클 경우 for문 재신 sum() + 컴프리헨션을 사용하여 간결성 및 속도 향상 개선

---

### 2920. 음계
- 비교 기준이 정수이므로 정수 리스트가 적합
- 값이 더 큰 숫자가 들어올 경우 오류의 가능성

---

### 3052. 나머지
- set을 이용하여 간단하게 가짓수를 구할 수도 있다.

---

### 5430. AC
- deque를 사용한다. pop 함수가 O(1).
- reverse 플래그를 사용하여 실제 배열 뒤집기 최소화
- n == 0 으로 빈 배열의 경우 빠르게 처리

---

### 17845. 수강 과목
#### 개선
- 'read()'로 한 번에 입력을 받아서 파싱하면 'strip()' 및 'input()' 호출을 줄일 수 있다.
- tuple을 생성하지 않고 바로 받아오므로 tuple 생성 오버헤드가 없어진다.

---

### 2675. 문자열 반복
- list comprehension을 사용 -> 속도 개선 및 코드 간결

---

### 16236. 아기 상어
#### 개선
- in range()보다는 비교연산자를 사용하고, shark[0] 보다는 지역 변수로 풀어서 쓰면 속도가 개선된다.
- BFS 탐색에서 순서 자체를 알맞게 진행하면, 조건을 따지지 않아도 tie-break가 해된다.
- deque.popletf()는 O(1)이지만, 파이썬 인터프리터 레벨에서는 오버헤드가 있다. 따라서 일반 리스트 및 인덱스를 사용하면 조금 더 빠르다.
- BFS를 돌 때마다 새롭게 리스트를 생성 및 초기화하면 O(n^2)로 비용이 크다. 따라서 visitied 배열을 전역으로 두고, timestamp 값으로 체크하자.

---

### 2206. 벽 부수고 이동하기
#### 개선
- visited를 3차원 배열로 만들어 '벽을 부순 여부'를 관리한다. 조건문이 간단해지므로 가독성이 개선된다.
- result 리스트 없이 도착 순간 print 후 break.
- 큐가 빌 때까지 도착 못하면 -1 출력.
- 개선 코드는 기존 코드 대비 조건 분기가 훨씬 간단하다.
- 개선 코드는 visited 배열을 3차원, deque에 3차원 값을 넣어 처리. 기존 코드는 2차원 및 4차원으로 처리. 따라서 deque에 값을 적게 넣는 경우 기존 코드가 시간/메모리 효율이 뛰어나고, 반대의 경우는 개선된 코드가 좋다.

---

### 2629. 양팔저울
#### 개선
- 현재까지 만들어진 무게만을 이용하여 계산하면 된다.
- 중복 처리를 해야한다.
- 따라서 집합을 사용하면 메모리와 시간 모두 줄일 수 있다.

---

### 16234. 인구 이동 (BFS/DFS)
#### 개선
- counts와 populations를 n*n으로 만들지 않고 연합 수만큼 동적으로 관리
- BFS 과정에서 연합이 만들어지지 않는 경우 False를 반환
- 메모리를 덜 사용할 수 있다.

---

### 23656. Jack and Jill
- 인터랙티브 문제로 입력과 출력에 따른 처리가 필요하다.
- 입력과 출력의 반복으로 문답이 이루어진다.
- 출력 시에 flush를 하여서 버퍼를 비워주어야 한다.

---

### 14908. 구두 수선공
- 최적의 작업 순서의 경우, 임의의 인접 작업 쌍을 고르게 되면 항상 s/t값의 큰 작업이 앞으로 와야 한다. 따라서 이 기준이 전체 작업 순서에 적용되어야 하므로, s/t를 기준으로 내림차 순 정렬을 한다.

---

### 10986. 나머지 합
- 처음부터 누적하여 합하는 누적합에 대해서 어떤 두 누적합의 (M으로 나누었을 때) 나머지가 동일하다면, 두 누적합의 사이에 해당하는 부분 누적합은 M으로 나누어 떨어지는 점을 이용한다.
- 따라서 순서쌍을 모두 구하는 문제
- sum(1~i) - sum(1~j) % M = 0 이라는 수식을 변형하여 sum(1~i) ≡ sum(1~j) (mod M) 으로 바꾸어 풀어낸다.