# 알고리즘 문제별 개선 메모

---

### 1406. 에디터 (문자열) 
#### 개선
- 문자열을 직접 조작할 경우 O(N) 시간이 소요된다.
- 단순 문자열 문제이지만 리스트로 처리하여 삽입/삭제 연산 속도 향상.
- 커서를 기준으로 두 개의 스택(left, right)을 활용한 방식이 효율적.

---

### 16953. A → B (BFS, greedy)
#### 개선 1: BFS + 조건 필터링
- 큐에 넣기 전 조건을 미리 체크하여 불필요한 탐색 줄임.
- 상태를 '(숫자, 연산횟수)' 형태의 튜플로 저장해 메모리 절약.
- 약 1900KB 메모리, 28ms 시간 절약
#### 개선 2: 역방향 + 그리디
- B에서 A로 거꾸로 이동하면서, 가능한 경우만 역추적
- 정수가 되지 않는 연산 제외 가능하므로 경우의 수가 급감
- 약 4400KB 메모리, 76ms 시간 절약

---

### 2108. 통계학(구현)
#### 개선
- 'collections.Counter'를 활용하여 간결하게 빈도 계산 가능.
- 'most_common' 함수는 빈도 순으로 정렬 및 동일 빈도 시 본래 순서 유지.
- 내장 함수 활용으로 코드 간결화 및 오류 방지

---

### 1967. 트리의 지름 (DFS, BFS)
- python으로 재귀 문제를 푸는 경우 (예: dfs), 제한에 걸리는 경우가 있다. 따라서 'sys.setrecursionlimit(10**6)'과 같이 설정한다.
#### 개선
- 노드 수에 맞는 n + 1 크기의 리스트 생성으로 메모리 절약
- graph[a].append((b, w)), graph[b].append((a, w)) 형태로 간선 양방향 연결
- 방문 여부를 리스트로 체크하여 중복을 제거하고 무한 루프를 방지
- DFS 대신 BFS를 2회 수행하여 임의 노드 → 가장 먼 노드 → 다시 가장 먼 노드로 이어지는 경로를 찾는 방식이 정확하고 효율적 (약 500KB 메모리, 220ms 시간 절약)

---

### 12865. 평범한 배낭 (DP)
#### 문제점
- 첫 아이템의 무게가 k보다 큰 경우 IndexError
#### 개선
- 1차원 DP로 최적화
- 227544 -> 36264 (KB), 4680 -> 2480 (ms)

---

### 11054. 가장 긴 바이토닉 부분 수열 (LIS, DP)
- 각 숫자가 끝이 되는 LIS를 계산
- 기준점으로 앞에서 LIS, 뒤에서 역으로 LIS를 계산

---

### 1920. 수 찾기
#### 개선
- 정수로 명시되어 있으므로 정수로 처리
- dict보다 set이 더 직관적이며 더 좋을 수 있다.
- print를 한 번만 출력하여 최적화

---

### 2805. 나무 자르기
- 리스트가 클 경우 for문 재신 sum() + 컴프리헨션을 사용하여 간결성 및 속도 향상 개선

---

### 2920. 음계
- 비교 기준이 정수이므로 정수 리스트가 적합
- 값이 더 큰 숫자가 들어올 경우 오류의 가능성

---

### 3052. 나머지
- set을 이용하여 간단하게 가짓수를 구할 수도 있다.