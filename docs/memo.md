# 알고리즘 문제별 개선 메모

---

### 1406. 에디터 (문자열) 
#### 개선
- 문자열을 직접 조작할 경우 O(N) 시간이 소요된다.
- 단순 문자열 문제이지만 리스트로 처리하여 삽입/삭제 연산 속도 향상.
- 커서를 기준으로 두 개의 스택(left, right)을 활용한 방식이 효율적.

---

### 16953. A → B (BFS, greedy)
#### 개선 1: BFS + 조건 필터링
- 큐에 넣기 전 조건을 미리 체크하여 불필요한 탐색 줄임.
- 상태를 '(숫자, 연산횟수)' 형태의 튜플로 저장해 메모리 절약.
- 약 1900KB 메모리, 28ms 시간 절약
#### 개선 2: 역방향 + 그리디
- B에서 A로 거꾸로 이동하면서, 가능한 경우만 역추적
- 정수가 되지 않는 연산 제외 가능하므로 경우의 수가 급감
- 약 4400KB 메모리, 76ms 시간 절약

---

### 2108. 통계학(구현)
#### 개선
- 'collections.Counter'를 활용하여 간결하게 빈도 계산 가능.
- 'most_common' 함수는 빈도 순으로 정렬 및 동일 빈도 시 본래 순서 유지.
- 내장 함수 활용으로 코드 간결화 및 오류 방지

---

### 1967. 트리의 지름 (DFS, BFS)
- python으로 재귀 문제를 푸는 경우 (예: dfs), 제한에 걸리는 경우가 있다. 따라서 'sys.setrecursionlimit(10**6)'과 같이 설정한다.
#### 개선
- 노드 수에 맞는 n + 1 크기의 리스트 생성으로 메모리 절약
- graph[a].append((b, w)), graph[b].append((a, w)) 형태로 간선 양방향 연결
- 방문 여부를 리스트로 체크하여 중복을 제거하고 무한 루프를 방지
- DFS 대신 BFS를 2회 수행하여 임의 노드 → 가장 먼 노드 → 다시 가장 먼 노드로 이어지는 경로를 찾는 방식이 정확하고 효율적 (약 500KB 메모리, 220ms 시간 절약)

---

### 12865. 평범한 배낭 (DP)
#### 문제점
- 첫 아이템의 무게가 k보다 큰 경우 IndexError
#### 개선
- 1차원 DP로 최적화
- 227544 -> 36264 (KB), 4680 -> 2480 (ms)

---

### 11054. 가장 긴 바이토닉 부분 수열 (LIS, DP)
- 각 숫자가 끝이 되는 LIS를 계산
- 기준점으로 앞에서 LIS, 뒤에서 역으로 LIS를 계산

---

### 1920. 수 찾기
#### 개선
- 정수로 명시되어 있으므로 정수로 처리
- dict보다 set이 더 직관적이며 더 좋을 수 있다.
- print를 한 번만 출력하여 최적화

---

### 2805. 나무 자르기
- 리스트가 클 경우 for문 재신 sum() + 컴프리헨션을 사용하여 간결성 및 속도 향상 개선

---

### 2920. 음계
- 비교 기준이 정수이므로 정수 리스트가 적합
- 값이 더 큰 숫자가 들어올 경우 오류의 가능성

---

### 3052. 나머지
- set을 이용하여 간단하게 가짓수를 구할 수도 있다.

---

### 5430. AC
- deque를 사용한다. pop 함수가 O(1).
- reverse 플래그를 사용하여 실제 배열 뒤집기 최소화
- n == 0 으로 빈 배열의 경우 빠르게 처리

---

### 17845. 수강 과목
#### 개선
- 'read()'로 한 번에 입력을 받아서 파싱하면 'strip()' 및 'input()' 호출을 줄일 수 있다.
- tuple을 생성하지 않고 바로 받아오므로 tuple 생성 오버헤드가 없어진다.

---

### 2675. 문자열 반복
- list comprehension을 사용 -> 속도 개선 및 코드 간결

---

### 16236. 아기 상어
#### 개선
- in range()보다는 비교연산자를 사용하고, shark[0] 보다는 지역 변수로 풀어서 쓰면 속도가 개선된다.
- BFS 탐색에서 순서 자체를 알맞게 진행하면, 조건을 따지지 않아도 tie-break가 해된다.
- deque.popletf()는 O(1)이지만, 파이썬 인터프리터 레벨에서는 오버헤드가 있다. 따라서 일반 리스트 및 인덱스를 사용하면 조금 더 빠르다.
- BFS를 돌 때마다 새롭게 리스트를 생성 및 초기화하면 O(n^2)로 비용이 크다. 따라서 visitied 배열을 전역으로 두고, timestamp 값으로 체크하자.

---

### 2206. 벽 부수고 이동하기
#### 개선
- visited를 3차원 배열로 만들어 '벽을 부순 여부'를 관리한다. 조건문이 간단해지므로 가독성이 개선된다.
- result 리스트 없이 도착 순간 print 후 break.
- 큐가 빌 때까지 도착 못하면 -1 출력.
- 개선 코드는 기존 코드 대비 조건 분기가 훨씬 간단하다.
- 개선 코드는 visited 배열을 3차원, deque에 3차원 값을 넣어 처리. 기존 코드는 2차원 및 4차원으로 처리. 따라서 deque에 값을 적게 넣는 경우 기존 코드가 시간/메모리 효율이 뛰어나고, 반대의 경우는 개선된 코드가 좋다.

---

### 2629. 양팔저울
#### 개선
- 현재까지 만들어진 무게만을 이용하여 계산하면 된다.
- 중복 처리를 해야한다.
- 따라서 집합을 사용하면 메모리와 시간 모두 줄일 수 있다.

---

### 16234. 인구 이동 (BFS/DFS)
#### 개선
- counts와 populations를 n*n으로 만들지 않고 연합 수만큼 동적으로 관리
- BFS 과정에서 연합이 만들어지지 않는 경우 False를 반환
- 메모리를 덜 사용할 수 있다.

---

### 23656. Jack and Jill
- 인터랙티브 문제로 입력과 출력에 따른 처리가 필요하다.
- 입력과 출력의 반복으로 문답이 이루어진다.
- 출력 시에 flush를 하여서 버퍼를 비워주어야 한다.

---

### 14908. 구두 수선공
- 최적의 작업 순서의 경우, 임의의 인접 작업 쌍을 고르게 되면 항상 s/t값의 큰 작업이 앞으로 와야 한다. 따라서 이 기준이 전체 작업 순서에 적용되어야 하므로, s/t를 기준으로 내림차 순 정렬을 한다.

---

### 10986. 나머지 합
- 처음부터 누적하여 합하는 누적합에 대해서 어떤 두 누적합의 (M으로 나누었을 때) 나머지가 동일하다면, 두 누적합의 사이에 해당하는 부분 누적합은 M으로 나누어 떨어지는 점을 이용한다.
- 따라서 순서쌍을 모두 구하는 문제
- sum(1~i) - sum(1~j) % M = 0 이라는 수식을 변형하여 sum(1~i) ≡ sum(1~j) (mod M) 으로 바꾸어 풀어낸다.

---

### 1699. 제곱수의 합
- 내가 사용한 BFS 방식은 불필요한 메모리 및 연산이 추가된다.
- DP가 표준적인 풀이 방법. 시간 복잡도: O(n√n). 공간 복잡도: O(n)
- 세 번째 방식으로 라그랑주의 네 제곱수 정리를 활용할 수 있다. 모든 자연수는 4개 이하의 제곱수 합으로 표현 가능하며, 라그랑주 보조 정리인 4^a(8b+7) 형태로 판별한다. 이론적 시간 복잡도: O(√n)

---

### 2294. 동전 2
- 동전을 정렬하여 x < 0 체크를 줄일 수 있고, 캐시 효율이 좋아진다.
- 이중 for문의 순서를 바꿔서 하나의 동전에 대해서 일괄 적용하면 캐시 효율이 증가하며 약간 빨라진다.
- 다른 방식으로 BFS를 사용할 수 있다. 

---

### 2225. 합분해
- 마지막 수가 0인 경우와 1 이상인 경우 2가지만으로 구분이 가능하다.
- i라는 수를 j개로 표현한다면, 전자는 dp[i][j-1] 이고 후자는 dp[i-1][j]이다.
- 따라서 두 값을 더하면 dp[i][j]가 된다.

---

### 2630. 색종이
#### 개선
- 각 블록이 단색인지를 판별할 때, 매번 반복문으로 검사하지 않고 사전에 2D prefix sum으로 구한다. O(1)
- 탐색은 재귀 대신 반복 방식으로 구현하여, 재귀 함수 호출의 오버헤드를 줄인다.

--- 

### 15654. N과 M (5)
#### 개선
- 기존의 dfs 방식을 사용하는 경우, 리스트를 사용하여 속도 및 메모리 개선
- 출력 시 파이썬의 unpack 기능을 사용하여 깔끔하게 출력한다. 'print(*seq)'
- 최적의 방법으로는 itertools를 사용한다. 내부적으로 C로 구현되어 있기에 속도 및 메모리 측면에서 뛰어나다. 또한, 방문 배열 및 깊이 관리가 필요하지 않다.

---

### 13549. 숨바꼭질 3
- 0-1 BFS 풀이 형태를 숙지

---

### 1916. 최소비용 구하기
#### 개선
- 2D 배열이 아닌 우선순위 큐(힙)을 사용하면 훨씬 빨라진다.
- 시간복잡도: O(n^2 + m) -> O(n)

---

### 14500. 테트로미노
#### 개선
- DFS + 가지치기. 남은 칸을 모두 최대값으로 계산하여서 pruning을 진행.
- 최대값을 이용하여 임의의 최대값을 미리 계산하여 pruning에 활용
- DFS로 확인이 불가능한 T모양의 경우 예외 처리 (O(1))
- 시간 복잡도: 평균 O(n x m x 4^4)

---

### 7662. 이중 우선순위 큐
#### 개선
- heapq 라이브러리로 2개의 힙 사용
- visited 배열로 유효한 데이터 관리. (딜레이 삭제)
- 총 k개의 연산. 각 연산의 시간 복잡도는 O(log n) 

---

### 1987. 알파벳
- Python3를 사용하여 문제를 풀 경우 시간초과(TLE)가 발생한다.
#### 개선
- PyPy: 재귀가 깊거나 DFS/BFS를 많이 호출하는 경우 PyPy를 사용한다. JIT 최적화로 반복적인 호출 및 연산에서 빠르다. (hot loop를 최적화된 머신코드로 바꾼다.)
- Stack 기반 DFS: 재귀 깊이 제한이 없으며, 함수 호출 오버헤드가 없다.
- local variable caching: 전역 변수 접근은 미세하게 느리다. 전역 dict 검색 -> key 해싱 -> 해시 충돌 검사 -> 값 반환의 과정을 거치기 때문이다. 반면에 지역 변수 접근은 해당 배열에 인덱스로 바로 접근한다.
- 메모리 초과 (MLE)도 주의해야 한다.

---

### 11444. 피보나치 수 6
- n이 매우 큰 경우 빠른 연산이 가능한 행렬을 사용하여야 한다.
#### 방법
- 1. 반복문
    시간복잡도 O(n), 공간복잡도 O(1)
    a, b = b, a + b
- 2. 메모이제이션(Top-down)
    시간복잡도 O(n), 공간 O(n)
    빠른 재귀 (from functools import lru_cache)
- 3. 재귀(Brute Force)
    O(2^n)
- 4. 행렬 거듭제곱
    시간복잡도 O(log n)
    M^n = (M^(n/2))^2 (n이 짝수)
    M^n = M * M^(n-1) (n이 홀수)
- 5. Binet’s Formula
    O(1)
    부동소수 계산 시에 오차가 발생할 수 있다.
    행렬 연산으로 유도

---

### 1918. 후위 표기식
#### 개선
- Shunting Yard 알고리즘
- 피연산자 -> 바로 출력
- 연산자 -> 스택의 top과 우선순위로 처리
- 여는 괄호 -> 스택에 push
- 닫는 괄호 -> 여는 괄호가 나올 때까지 pop

---

### 9935. 문자열 폭발
- 문자열의 문자를 앞에서부터 하나씩 스택에 push
- push할 때마다 top이 타겟 문자열과 동일한 경우 pop

---

### 2448. 별 찍기 - 11
- 삼각형의 가장 윗 지점을 기준으로 분할정복
- 그림을 그리기 위해 공백이 저장되어있는 2차원 배열을 사용

---

### 13172. Σ
- 페르마의 소정리 기반으로 최적화
- p가 소수이고 b가 p로 나누어떨어지지 않으면, b^(p−1) ≡ 1 (mod p)
- 다른 방법으로 확장 유클리드가 있다.

---

### 30805. 사전 순 최대 공통 부분 수열
#### 개선
- 큰 숫자를 우선적으로 선택하는 greedy 방식을 사용하여 시간 복잡도를 낮춤
- 배열 등장 위치를 사전처럼 사용하여 O(1)으로 개선

---

### 1766. 문제집
- 선행 노드의 개수를 기록하여 위상 정렬
- 같은 위상이라면 작은 번호가 먼저이므로 heap을 사용

--- 

### 1202. 보석 도둑
- 보석 및 가방의 개수가 각 최대 30만이므로, N * M 수준의 방식은 TLE 된다.
- heap을 사용하여 선형 수준으로 해결한다.
- 작은 무게 순으로 모두 정렬한다.
- 작은 무게의 가방부터 시작하며, 현재 가방에 넣을 수 있는 보석들을 모두 heap에 넣는다.
- heap이 비어있지 않는 경우, heap에서 하나의 보석을 꺼내 집어넣는다.

---

### 1005. ACM Craft
- 순서를 정하기 위해 위상 정렬을 사용
- 현재 노드의 총합 시간으로 연결된 다음 노드의 시간을 갱신
- 타겟 노드 차례일 경우 즉시 종료

---